// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: system.proto

package system

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Casbin_AddPolicy_FullMethodName = "/system.Casbin/AddPolicy"
	Casbin_Enforce_FullMethodName   = "/system.Casbin/Enforce"
)

// CasbinClient is the client API for Casbin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CasbinClient interface {
	AddPolicy(ctx context.Context, in *AddPolicyReq, opts ...grpc.CallOption) (*AddPolicyResp, error)
	Enforce(ctx context.Context, in *EnforceReq, opts ...grpc.CallOption) (*EnforceResp, error)
}

type casbinClient struct {
	cc grpc.ClientConnInterface
}

func NewCasbinClient(cc grpc.ClientConnInterface) CasbinClient {
	return &casbinClient{cc}
}

func (c *casbinClient) AddPolicy(ctx context.Context, in *AddPolicyReq, opts ...grpc.CallOption) (*AddPolicyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddPolicyResp)
	err := c.cc.Invoke(ctx, Casbin_AddPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casbinClient) Enforce(ctx context.Context, in *EnforceReq, opts ...grpc.CallOption) (*EnforceResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnforceResp)
	err := c.cc.Invoke(ctx, Casbin_Enforce_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CasbinServer is the server API for Casbin service.
// All implementations must embed UnimplementedCasbinServer
// for forward compatibility.
type CasbinServer interface {
	AddPolicy(context.Context, *AddPolicyReq) (*AddPolicyResp, error)
	Enforce(context.Context, *EnforceReq) (*EnforceResp, error)
	mustEmbedUnimplementedCasbinServer()
}

// UnimplementedCasbinServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCasbinServer struct{}

func (UnimplementedCasbinServer) AddPolicy(context.Context, *AddPolicyReq) (*AddPolicyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPolicy not implemented")
}
func (UnimplementedCasbinServer) Enforce(context.Context, *EnforceReq) (*EnforceResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enforce not implemented")
}
func (UnimplementedCasbinServer) mustEmbedUnimplementedCasbinServer() {}
func (UnimplementedCasbinServer) testEmbeddedByValue()                {}

// UnsafeCasbinServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CasbinServer will
// result in compilation errors.
type UnsafeCasbinServer interface {
	mustEmbedUnimplementedCasbinServer()
}

func RegisterCasbinServer(s grpc.ServiceRegistrar, srv CasbinServer) {
	// If the following call pancis, it indicates UnimplementedCasbinServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Casbin_ServiceDesc, srv)
}

func _Casbin_AddPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPolicyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServer).AddPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Casbin_AddPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServer).AddPolicy(ctx, req.(*AddPolicyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Casbin_Enforce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnforceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServer).Enforce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Casbin_Enforce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServer).Enforce(ctx, req.(*EnforceReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Casbin_ServiceDesc is the grpc.ServiceDesc for Casbin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Casbin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.Casbin",
	HandlerType: (*CasbinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddPolicy",
			Handler:    _Casbin_AddPolicy_Handler,
		},
		{
			MethodName: "Enforce",
			Handler:    _Casbin_Enforce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}

const (
	Role_AddRole_FullMethodName           = "/system.Role/AddRole"
	Role_DeleteRole_FullMethodName        = "/system.Role/DeleteRole"
	Role_UpdateRole_FullMethodName        = "/system.Role/UpdateRole"
	Role_RoleTree_FullMethodName          = "/system.Role/RoleTree"
	Role_SetRolePolicies_FullMethodName   = "/system.Role/SetRolePolicies"
	Role_QueryRolePolicies_FullMethodName = "/system.Role/QueryRolePolicies"
)

// RoleClient is the client API for Role service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 角色服务
type RoleClient interface {
	AddRole(ctx context.Context, in *AddRoleReq, opts ...grpc.CallOption) (*AddRoleResp, error)
	DeleteRole(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*DeleteRoleResp, error)
	UpdateRole(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*UpdateRoleResp, error)
	RoleTree(ctx context.Context, in *RoleTreeReq, opts ...grpc.CallOption) (*RoleTreeListResp, error)
	SetRolePolicies(ctx context.Context, in *SetRolePoliciesReq, opts ...grpc.CallOption) (*SetRolePoliciesResp, error)
	QueryRolePolicies(ctx context.Context, in *QueryRolePoliciesReq, opts ...grpc.CallOption) (*QueryRolePoliciesResp, error)
}

type roleClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleClient(cc grpc.ClientConnInterface) RoleClient {
	return &roleClient{cc}
}

func (c *roleClient) AddRole(ctx context.Context, in *AddRoleReq, opts ...grpc.CallOption) (*AddRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddRoleResp)
	err := c.cc.Invoke(ctx, Role_AddRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) DeleteRole(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*DeleteRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRoleResp)
	err := c.cc.Invoke(ctx, Role_DeleteRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) UpdateRole(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*UpdateRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRoleResp)
	err := c.cc.Invoke(ctx, Role_UpdateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleTree(ctx context.Context, in *RoleTreeReq, opts ...grpc.CallOption) (*RoleTreeListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleTreeListResp)
	err := c.cc.Invoke(ctx, Role_RoleTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) SetRolePolicies(ctx context.Context, in *SetRolePoliciesReq, opts ...grpc.CallOption) (*SetRolePoliciesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRolePoliciesResp)
	err := c.cc.Invoke(ctx, Role_SetRolePolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) QueryRolePolicies(ctx context.Context, in *QueryRolePoliciesReq, opts ...grpc.CallOption) (*QueryRolePoliciesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryRolePoliciesResp)
	err := c.cc.Invoke(ctx, Role_QueryRolePolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServer is the server API for Role service.
// All implementations must embed UnimplementedRoleServer
// for forward compatibility.
//
// 角色服务
type RoleServer interface {
	AddRole(context.Context, *AddRoleReq) (*AddRoleResp, error)
	DeleteRole(context.Context, *DeleteRoleReq) (*DeleteRoleResp, error)
	UpdateRole(context.Context, *UpdateRoleReq) (*UpdateRoleResp, error)
	RoleTree(context.Context, *RoleTreeReq) (*RoleTreeListResp, error)
	SetRolePolicies(context.Context, *SetRolePoliciesReq) (*SetRolePoliciesResp, error)
	QueryRolePolicies(context.Context, *QueryRolePoliciesReq) (*QueryRolePoliciesResp, error)
	mustEmbedUnimplementedRoleServer()
}

// UnimplementedRoleServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoleServer struct{}

func (UnimplementedRoleServer) AddRole(context.Context, *AddRoleReq) (*AddRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRole not implemented")
}
func (UnimplementedRoleServer) DeleteRole(context.Context, *DeleteRoleReq) (*DeleteRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServer) UpdateRole(context.Context, *UpdateRoleReq) (*UpdateRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServer) RoleTree(context.Context, *RoleTreeReq) (*RoleTreeListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleTree not implemented")
}
func (UnimplementedRoleServer) SetRolePolicies(context.Context, *SetRolePoliciesReq) (*SetRolePoliciesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRolePolicies not implemented")
}
func (UnimplementedRoleServer) QueryRolePolicies(context.Context, *QueryRolePoliciesReq) (*QueryRolePoliciesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRolePolicies not implemented")
}
func (UnimplementedRoleServer) mustEmbedUnimplementedRoleServer() {}
func (UnimplementedRoleServer) testEmbeddedByValue()              {}

// UnsafeRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServer will
// result in compilation errors.
type UnsafeRoleServer interface {
	mustEmbedUnimplementedRoleServer()
}

func RegisterRoleServer(s grpc.ServiceRegistrar, srv RoleServer) {
	// If the following call pancis, it indicates UnimplementedRoleServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Role_ServiceDesc, srv)
}

func _Role_AddRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).AddRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_AddRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).AddRole(ctx, req.(*AddRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_DeleteRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).DeleteRole(ctx, req.(*DeleteRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_UpdateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).UpdateRole(ctx, req.(*UpdateRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleTree(ctx, req.(*RoleTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_SetRolePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRolePoliciesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).SetRolePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_SetRolePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).SetRolePolicies(ctx, req.(*SetRolePoliciesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_QueryRolePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRolePoliciesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).QueryRolePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_QueryRolePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).QueryRolePolicies(ctx, req.(*QueryRolePoliciesReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Role_ServiceDesc is the grpc.ServiceDesc for Role service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Role_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.Role",
	HandlerType: (*RoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRole",
			Handler:    _Role_AddRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _Role_DeleteRole_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _Role_UpdateRole_Handler,
		},
		{
			MethodName: "RoleTree",
			Handler:    _Role_RoleTree_Handler,
		},
		{
			MethodName: "SetRolePolicies",
			Handler:    _Role_SetRolePolicies_Handler,
		},
		{
			MethodName: "QueryRolePolicies",
			Handler:    _Role_QueryRolePolicies_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}

const (
	User_QueryUserDetail_FullMethodName    = "/system.User/QueryUserDetail"
	User_QueryUserList_FullMethodName      = "/system.User/QueryUserList"
	User_FindUserByUsername_FullMethodName = "/system.User/FindUserByUsername"
	User_Register_FullMethodName           = "/system.User/Register"
	User_SetUserInfo_FullMethodName        = "/system.User/SetUserInfo"
	User_SetSelfInfo_FullMethodName        = "/system.User/SetSelfInfo"
	User_QuerySelfInfo_FullMethodName      = "/system.User/QuerySelfInfo"
	User_SetUserRole_FullMethodName        = "/system.User/SetUserRole"
	User_ResetPassword_FullMethodName      = "/system.User/ResetPassword"
	User_ChangePassword_FullMethodName     = "/system.User/ChangePassword"
	User_DeleteUser_FullMethodName         = "/system.User/DeleteUser"
)

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	QueryUserDetail(ctx context.Context, in *QueryUserDetailReq, opts ...grpc.CallOption) (*QueryUserDetailResp, error)
	QueryUserList(ctx context.Context, in *QueryUserListReq, opts ...grpc.CallOption) (*QueryUserListResp, error)
	FindUserByUsername(ctx context.Context, in *FindUserByUsernameReq, opts ...grpc.CallOption) (*FindUserByUsernameResp, error)
	Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error)
	SetUserInfo(ctx context.Context, in *SetUserInfoReq, opts ...grpc.CallOption) (*SetUserInfoResp, error)
	SetSelfInfo(ctx context.Context, in *SetSelfInfoReq, opts ...grpc.CallOption) (*SetSelfInfoResp, error)
	QuerySelfInfo(ctx context.Context, in *QuerySelfInfoReq, opts ...grpc.CallOption) (*QuerySelfInfoResp, error)
	SetUserRole(ctx context.Context, in *SetUserRoleReq, opts ...grpc.CallOption) (*SetUserRoleResp, error)
	ResetPassword(ctx context.Context, in *ResetPasswordReq, opts ...grpc.CallOption) (*ResetPasswordResp, error)
	ChangePassword(ctx context.Context, in *ChangePasswordReq, opts ...grpc.CallOption) (*ChangePasswordResp, error)
	DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) QueryUserDetail(ctx context.Context, in *QueryUserDetailReq, opts ...grpc.CallOption) (*QueryUserDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUserDetailResp)
	err := c.cc.Invoke(ctx, User_QueryUserDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) QueryUserList(ctx context.Context, in *QueryUserListReq, opts ...grpc.CallOption) (*QueryUserListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUserListResp)
	err := c.cc.Invoke(ctx, User_QueryUserList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) FindUserByUsername(ctx context.Context, in *FindUserByUsernameReq, opts ...grpc.CallOption) (*FindUserByUsernameResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindUserByUsernameResp)
	err := c.cc.Invoke(ctx, User_FindUserByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResp)
	err := c.cc.Invoke(ctx, User_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetUserInfo(ctx context.Context, in *SetUserInfoReq, opts ...grpc.CallOption) (*SetUserInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserInfoResp)
	err := c.cc.Invoke(ctx, User_SetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetSelfInfo(ctx context.Context, in *SetSelfInfoReq, opts ...grpc.CallOption) (*SetSelfInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSelfInfoResp)
	err := c.cc.Invoke(ctx, User_SetSelfInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) QuerySelfInfo(ctx context.Context, in *QuerySelfInfoReq, opts ...grpc.CallOption) (*QuerySelfInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySelfInfoResp)
	err := c.cc.Invoke(ctx, User_QuerySelfInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetUserRole(ctx context.Context, in *SetUserRoleReq, opts ...grpc.CallOption) (*SetUserRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserRoleResp)
	err := c.cc.Invoke(ctx, User_SetUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ResetPassword(ctx context.Context, in *ResetPasswordReq, opts ...grpc.CallOption) (*ResetPasswordResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasswordResp)
	err := c.cc.Invoke(ctx, User_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ChangePassword(ctx context.Context, in *ChangePasswordReq, opts ...grpc.CallOption) (*ChangePasswordResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangePasswordResp)
	err := c.cc.Invoke(ctx, User_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResp)
	err := c.cc.Invoke(ctx, User_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility.
type UserServer interface {
	QueryUserDetail(context.Context, *QueryUserDetailReq) (*QueryUserDetailResp, error)
	QueryUserList(context.Context, *QueryUserListReq) (*QueryUserListResp, error)
	FindUserByUsername(context.Context, *FindUserByUsernameReq) (*FindUserByUsernameResp, error)
	Register(context.Context, *RegisterReq) (*RegisterResp, error)
	SetUserInfo(context.Context, *SetUserInfoReq) (*SetUserInfoResp, error)
	SetSelfInfo(context.Context, *SetSelfInfoReq) (*SetSelfInfoResp, error)
	QuerySelfInfo(context.Context, *QuerySelfInfoReq) (*QuerySelfInfoResp, error)
	SetUserRole(context.Context, *SetUserRoleReq) (*SetUserRoleResp, error)
	ResetPassword(context.Context, *ResetPasswordReq) (*ResetPasswordResp, error)
	ChangePassword(context.Context, *ChangePasswordReq) (*ChangePasswordResp, error)
	DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResp, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServer struct{}

func (UnimplementedUserServer) QueryUserDetail(context.Context, *QueryUserDetailReq) (*QueryUserDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserDetail not implemented")
}
func (UnimplementedUserServer) QueryUserList(context.Context, *QueryUserListReq) (*QueryUserListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserList not implemented")
}
func (UnimplementedUserServer) FindUserByUsername(context.Context, *FindUserByUsernameReq) (*FindUserByUsernameResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindUserByUsername not implemented")
}
func (UnimplementedUserServer) Register(context.Context, *RegisterReq) (*RegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserServer) SetUserInfo(context.Context, *SetUserInfoReq) (*SetUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserInfo not implemented")
}
func (UnimplementedUserServer) SetSelfInfo(context.Context, *SetSelfInfoReq) (*SetSelfInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSelfInfo not implemented")
}
func (UnimplementedUserServer) QuerySelfInfo(context.Context, *QuerySelfInfoReq) (*QuerySelfInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySelfInfo not implemented")
}
func (UnimplementedUserServer) SetUserRole(context.Context, *SetUserRoleReq) (*SetUserRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserRole not implemented")
}
func (UnimplementedUserServer) ResetPassword(context.Context, *ResetPasswordReq) (*ResetPasswordResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUserServer) ChangePassword(context.Context, *ChangePasswordReq) (*ChangePasswordResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServer) DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}
func (UnimplementedUserServer) testEmbeddedByValue()              {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	// If the following call pancis, it indicates UnimplementedUserServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_QueryUserDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).QueryUserDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_QueryUserDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).QueryUserDetail(ctx, req.(*QueryUserDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_QueryUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).QueryUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_QueryUserList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).QueryUserList(ctx, req.(*QueryUserListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_FindUserByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUserByUsernameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).FindUserByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_FindUserByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).FindUserByUsername(ctx, req.(*FindUserByUsernameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Register(ctx, req.(*RegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetUserInfo(ctx, req.(*SetUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetSelfInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSelfInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetSelfInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetSelfInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetSelfInfo(ctx, req.(*SetSelfInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_QuerySelfInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySelfInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).QuerySelfInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_QuerySelfInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).QuerySelfInfo(ctx, req.(*QuerySelfInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetUserRole(ctx, req.(*SetUserRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ResetPassword(ctx, req.(*ResetPasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ChangePassword(ctx, req.(*ChangePasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).DeleteUser(ctx, req.(*DeleteUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryUserDetail",
			Handler:    _User_QueryUserDetail_Handler,
		},
		{
			MethodName: "QueryUserList",
			Handler:    _User_QueryUserList_Handler,
		},
		{
			MethodName: "FindUserByUsername",
			Handler:    _User_FindUserByUsername_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _User_Register_Handler,
		},
		{
			MethodName: "SetUserInfo",
			Handler:    _User_SetUserInfo_Handler,
		},
		{
			MethodName: "SetSelfInfo",
			Handler:    _User_SetSelfInfo_Handler,
		},
		{
			MethodName: "QuerySelfInfo",
			Handler:    _User_QuerySelfInfo_Handler,
		},
		{
			MethodName: "SetUserRole",
			Handler:    _User_SetUserRole_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _User_ResetPassword_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _User_ChangePassword_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _User_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}

const (
	ApiService_CreateApi_FullMethodName      = "/system.ApiService/CreateApi"
	ApiService_QueryAllApi_FullMethodName    = "/system.ApiService/QueryAllApi"
	ApiService_DeleteApi_FullMethodName      = "/system.ApiService/DeleteApi"
	ApiService_UpdateApi_FullMethodName      = "/system.ApiService/UpdateApi"
	ApiService_QueryApiDetail_FullMethodName = "/system.ApiService/QueryApiDetail"
)

// ApiServiceClient is the client API for ApiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiServiceClient interface {
	CreateApi(ctx context.Context, in *CreateApiReq, opts ...grpc.CallOption) (*CreateApiResp, error)
	QueryAllApi(ctx context.Context, in *QueryAllApiReq, opts ...grpc.CallOption) (*QueryAllApiResp, error)
	DeleteApi(ctx context.Context, in *DeleteApiReq, opts ...grpc.CallOption) (*DeleteApiResp, error)
	UpdateApi(ctx context.Context, in *UpdateApiReq, opts ...grpc.CallOption) (*UpdateApiResp, error)
	QueryApiDetail(ctx context.Context, in *QueryApiDetailReq, opts ...grpc.CallOption) (*QueryApiDetailResp, error)
}

type apiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewApiServiceClient(cc grpc.ClientConnInterface) ApiServiceClient {
	return &apiServiceClient{cc}
}

func (c *apiServiceClient) CreateApi(ctx context.Context, in *CreateApiReq, opts ...grpc.CallOption) (*CreateApiResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateApiResp)
	err := c.cc.Invoke(ctx, ApiService_CreateApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) QueryAllApi(ctx context.Context, in *QueryAllApiReq, opts ...grpc.CallOption) (*QueryAllApiResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryAllApiResp)
	err := c.cc.Invoke(ctx, ApiService_QueryAllApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) DeleteApi(ctx context.Context, in *DeleteApiReq, opts ...grpc.CallOption) (*DeleteApiResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteApiResp)
	err := c.cc.Invoke(ctx, ApiService_DeleteApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) UpdateApi(ctx context.Context, in *UpdateApiReq, opts ...grpc.CallOption) (*UpdateApiResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateApiResp)
	err := c.cc.Invoke(ctx, ApiService_UpdateApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) QueryApiDetail(ctx context.Context, in *QueryApiDetailReq, opts ...grpc.CallOption) (*QueryApiDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryApiDetailResp)
	err := c.cc.Invoke(ctx, ApiService_QueryApiDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServiceServer is the server API for ApiService service.
// All implementations must embed UnimplementedApiServiceServer
// for forward compatibility.
type ApiServiceServer interface {
	CreateApi(context.Context, *CreateApiReq) (*CreateApiResp, error)
	QueryAllApi(context.Context, *QueryAllApiReq) (*QueryAllApiResp, error)
	DeleteApi(context.Context, *DeleteApiReq) (*DeleteApiResp, error)
	UpdateApi(context.Context, *UpdateApiReq) (*UpdateApiResp, error)
	QueryApiDetail(context.Context, *QueryApiDetailReq) (*QueryApiDetailResp, error)
	mustEmbedUnimplementedApiServiceServer()
}

// UnimplementedApiServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedApiServiceServer struct{}

func (UnimplementedApiServiceServer) CreateApi(context.Context, *CreateApiReq) (*CreateApiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApi not implemented")
}
func (UnimplementedApiServiceServer) QueryAllApi(context.Context, *QueryAllApiReq) (*QueryAllApiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllApi not implemented")
}
func (UnimplementedApiServiceServer) DeleteApi(context.Context, *DeleteApiReq) (*DeleteApiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApi not implemented")
}
func (UnimplementedApiServiceServer) UpdateApi(context.Context, *UpdateApiReq) (*UpdateApiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApi not implemented")
}
func (UnimplementedApiServiceServer) QueryApiDetail(context.Context, *QueryApiDetailReq) (*QueryApiDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryApiDetail not implemented")
}
func (UnimplementedApiServiceServer) mustEmbedUnimplementedApiServiceServer() {}
func (UnimplementedApiServiceServer) testEmbeddedByValue()                    {}

// UnsafeApiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiServiceServer will
// result in compilation errors.
type UnsafeApiServiceServer interface {
	mustEmbedUnimplementedApiServiceServer()
}

func RegisterApiServiceServer(s grpc.ServiceRegistrar, srv ApiServiceServer) {
	// If the following call pancis, it indicates UnimplementedApiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ApiService_ServiceDesc, srv)
}

func _ApiService_CreateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).CreateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_CreateApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).CreateApi(ctx, req.(*CreateApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_QueryAllApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).QueryAllApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_QueryAllApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).QueryAllApi(ctx, req.(*QueryAllApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_DeleteApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).DeleteApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_DeleteApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).DeleteApi(ctx, req.(*DeleteApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_UpdateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).UpdateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_UpdateApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).UpdateApi(ctx, req.(*UpdateApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_QueryApiDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryApiDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).QueryApiDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_QueryApiDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).QueryApiDetail(ctx, req.(*QueryApiDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiService_ServiceDesc is the grpc.ServiceDesc for ApiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.ApiService",
	HandlerType: (*ApiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateApi",
			Handler:    _ApiService_CreateApi_Handler,
		},
		{
			MethodName: "QueryAllApi",
			Handler:    _ApiService_QueryAllApi_Handler,
		},
		{
			MethodName: "DeleteApi",
			Handler:    _ApiService_DeleteApi_Handler,
		},
		{
			MethodName: "UpdateApi",
			Handler:    _ApiService_UpdateApi_Handler,
		},
		{
			MethodName: "QueryApiDetail",
			Handler:    _ApiService_QueryApiDetail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}

const (
	MenuService_CreateMenu_FullMethodName        = "/system.MenuService/CreateMenu"
	MenuService_QueryAllMenuTree_FullMethodName  = "/system.MenuService/QueryAllMenuTree"
	MenuService_QueryRoleMenuTree_FullMethodName = "/system.MenuService/QueryRoleMenuTree"
	MenuService_UpdateRoleMenu_FullMethodName    = "/system.MenuService/UpdateRoleMenu"
	MenuService_DeleteMenu_FullMethodName        = "/system.MenuService/DeleteMenu"
	MenuService_QueryMenuDetail_FullMethodName   = "/system.MenuService/QueryMenuDetail"
	MenuService_UpdateMenu_FullMethodName        = "/system.MenuService/UpdateMenu"
)

// MenuServiceClient is the client API for MenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuServiceClient interface {
	CreateMenu(ctx context.Context, in *CreateMenuReq, opts ...grpc.CallOption) (*CreateMenuResp, error)
	QueryAllMenuTree(ctx context.Context, in *QueryAllMenuTreeReq, opts ...grpc.CallOption) (*QueryAllMenuTreeResp, error)
	QueryRoleMenuTree(ctx context.Context, in *QueryRoleMenuTreeReq, opts ...grpc.CallOption) (*QueryRoleMenuTreeResp, error)
	UpdateRoleMenu(ctx context.Context, in *UpdateRoleMenuReq, opts ...grpc.CallOption) (*UpdateRoleMenuResp, error)
	DeleteMenu(ctx context.Context, in *DeleteMenuReq, opts ...grpc.CallOption) (*DeleteMenuResp, error)
	QueryMenuDetail(ctx context.Context, in *QueryMenuDetailReq, opts ...grpc.CallOption) (*QueryMenuDetailResp, error)
	UpdateMenu(ctx context.Context, in *UpdateMenuReq, opts ...grpc.CallOption) (*UpdateMenuResp, error)
}

type menuServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuServiceClient(cc grpc.ClientConnInterface) MenuServiceClient {
	return &menuServiceClient{cc}
}

func (c *menuServiceClient) CreateMenu(ctx context.Context, in *CreateMenuReq, opts ...grpc.CallOption) (*CreateMenuResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMenuResp)
	err := c.cc.Invoke(ctx, MenuService_CreateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) QueryAllMenuTree(ctx context.Context, in *QueryAllMenuTreeReq, opts ...grpc.CallOption) (*QueryAllMenuTreeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryAllMenuTreeResp)
	err := c.cc.Invoke(ctx, MenuService_QueryAllMenuTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) QueryRoleMenuTree(ctx context.Context, in *QueryRoleMenuTreeReq, opts ...grpc.CallOption) (*QueryRoleMenuTreeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryRoleMenuTreeResp)
	err := c.cc.Invoke(ctx, MenuService_QueryRoleMenuTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) UpdateRoleMenu(ctx context.Context, in *UpdateRoleMenuReq, opts ...grpc.CallOption) (*UpdateRoleMenuResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRoleMenuResp)
	err := c.cc.Invoke(ctx, MenuService_UpdateRoleMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) DeleteMenu(ctx context.Context, in *DeleteMenuReq, opts ...grpc.CallOption) (*DeleteMenuResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMenuResp)
	err := c.cc.Invoke(ctx, MenuService_DeleteMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) QueryMenuDetail(ctx context.Context, in *QueryMenuDetailReq, opts ...grpc.CallOption) (*QueryMenuDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryMenuDetailResp)
	err := c.cc.Invoke(ctx, MenuService_QueryMenuDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) UpdateMenu(ctx context.Context, in *UpdateMenuReq, opts ...grpc.CallOption) (*UpdateMenuResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMenuResp)
	err := c.cc.Invoke(ctx, MenuService_UpdateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServiceServer is the server API for MenuService service.
// All implementations must embed UnimplementedMenuServiceServer
// for forward compatibility.
type MenuServiceServer interface {
	CreateMenu(context.Context, *CreateMenuReq) (*CreateMenuResp, error)
	QueryAllMenuTree(context.Context, *QueryAllMenuTreeReq) (*QueryAllMenuTreeResp, error)
	QueryRoleMenuTree(context.Context, *QueryRoleMenuTreeReq) (*QueryRoleMenuTreeResp, error)
	UpdateRoleMenu(context.Context, *UpdateRoleMenuReq) (*UpdateRoleMenuResp, error)
	DeleteMenu(context.Context, *DeleteMenuReq) (*DeleteMenuResp, error)
	QueryMenuDetail(context.Context, *QueryMenuDetailReq) (*QueryMenuDetailResp, error)
	UpdateMenu(context.Context, *UpdateMenuReq) (*UpdateMenuResp, error)
	mustEmbedUnimplementedMenuServiceServer()
}

// UnimplementedMenuServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMenuServiceServer struct{}

func (UnimplementedMenuServiceServer) CreateMenu(context.Context, *CreateMenuReq) (*CreateMenuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenu not implemented")
}
func (UnimplementedMenuServiceServer) QueryAllMenuTree(context.Context, *QueryAllMenuTreeReq) (*QueryAllMenuTreeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllMenuTree not implemented")
}
func (UnimplementedMenuServiceServer) QueryRoleMenuTree(context.Context, *QueryRoleMenuTreeReq) (*QueryRoleMenuTreeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRoleMenuTree not implemented")
}
func (UnimplementedMenuServiceServer) UpdateRoleMenu(context.Context, *UpdateRoleMenuReq) (*UpdateRoleMenuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoleMenu not implemented")
}
func (UnimplementedMenuServiceServer) DeleteMenu(context.Context, *DeleteMenuReq) (*DeleteMenuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenu not implemented")
}
func (UnimplementedMenuServiceServer) QueryMenuDetail(context.Context, *QueryMenuDetailReq) (*QueryMenuDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMenuDetail not implemented")
}
func (UnimplementedMenuServiceServer) UpdateMenu(context.Context, *UpdateMenuReq) (*UpdateMenuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedMenuServiceServer) mustEmbedUnimplementedMenuServiceServer() {}
func (UnimplementedMenuServiceServer) testEmbeddedByValue()                     {}

// UnsafeMenuServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServiceServer will
// result in compilation errors.
type UnsafeMenuServiceServer interface {
	mustEmbedUnimplementedMenuServiceServer()
}

func RegisterMenuServiceServer(s grpc.ServiceRegistrar, srv MenuServiceServer) {
	// If the following call pancis, it indicates UnimplementedMenuServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MenuService_ServiceDesc, srv)
}

func _MenuService_CreateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).CreateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_CreateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).CreateMenu(ctx, req.(*CreateMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_QueryAllMenuTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllMenuTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).QueryAllMenuTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_QueryAllMenuTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).QueryAllMenuTree(ctx, req.(*QueryAllMenuTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_QueryRoleMenuTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRoleMenuTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).QueryRoleMenuTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_QueryRoleMenuTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).QueryRoleMenuTree(ctx, req.(*QueryRoleMenuTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_UpdateRoleMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).UpdateRoleMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_UpdateRoleMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).UpdateRoleMenu(ctx, req.(*UpdateRoleMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_DeleteMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).DeleteMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_DeleteMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).DeleteMenu(ctx, req.(*DeleteMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_QueryMenuDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMenuDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).QueryMenuDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_QueryMenuDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).QueryMenuDetail(ctx, req.(*QueryMenuDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_UpdateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).UpdateMenu(ctx, req.(*UpdateMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuService_ServiceDesc is the grpc.ServiceDesc for MenuService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.MenuService",
	HandlerType: (*MenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMenu",
			Handler:    _MenuService_CreateMenu_Handler,
		},
		{
			MethodName: "QueryAllMenuTree",
			Handler:    _MenuService_QueryAllMenuTree_Handler,
		},
		{
			MethodName: "QueryRoleMenuTree",
			Handler:    _MenuService_QueryRoleMenuTree_Handler,
		},
		{
			MethodName: "UpdateRoleMenu",
			Handler:    _MenuService_UpdateRoleMenu_Handler,
		},
		{
			MethodName: "DeleteMenu",
			Handler:    _MenuService_DeleteMenu_Handler,
		},
		{
			MethodName: "QueryMenuDetail",
			Handler:    _MenuService_QueryMenuDetail_Handler,
		},
		{
			MethodName: "UpdateMenu",
			Handler:    _MenuService_UpdateMenu_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}

const (
	DictionaryService_CreateDictionary_FullMethodName            = "/system.DictionaryService/CreateDictionary"
	DictionaryService_QueryDictionaryDetail_FullMethodName       = "/system.DictionaryService/QueryDictionaryDetail"
	DictionaryService_QueryAllDictionary_FullMethodName          = "/system.DictionaryService/QueryAllDictionary"
	DictionaryService_UpdateDictionary_FullMethodName            = "/system.DictionaryService/UpdateDictionary"
	DictionaryService_DeleteDictionary_FullMethodName            = "/system.DictionaryService/DeleteDictionary"
	DictionaryService_CreateDictionaryDetail_FullMethodName      = "/system.DictionaryService/CreateDictionaryDetail"
	DictionaryService_QueryDictionaryDetailDetail_FullMethodName = "/system.DictionaryService/QueryDictionaryDetailDetail"
	DictionaryService_QueryAllDictionaryDetail_FullMethodName    = "/system.DictionaryService/QueryAllDictionaryDetail"
	DictionaryService_UpdateDictionaryDetail_FullMethodName      = "/system.DictionaryService/UpdateDictionaryDetail"
	DictionaryService_DeleteDictionaryDetail_FullMethodName      = "/system.DictionaryService/DeleteDictionaryDetail"
	DictionaryService_QueryDictionaryList_FullMethodName         = "/system.DictionaryService/QueryDictionaryList"
)

// DictionaryServiceClient is the client API for DictionaryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DictionaryServiceClient interface {
	CreateDictionary(ctx context.Context, in *CreateDictionaryReq, opts ...grpc.CallOption) (*CreateDictionaryResp, error)
	QueryDictionaryDetail(ctx context.Context, in *QueryDictionaryDetailReq, opts ...grpc.CallOption) (*QueryDictionaryDetailResp, error)
	QueryAllDictionary(ctx context.Context, in *QueryAllDictionaryReq, opts ...grpc.CallOption) (*QueryAllDictionaryResp, error)
	UpdateDictionary(ctx context.Context, in *UpdateDictionaryReq, opts ...grpc.CallOption) (*UpdateDictionaryResp, error)
	DeleteDictionary(ctx context.Context, in *DeleteDictionaryReq, opts ...grpc.CallOption) (*DeleteDictionaryResp, error)
	CreateDictionaryDetail(ctx context.Context, in *CreateDictionaryDetailReq, opts ...grpc.CallOption) (*CreateDictionaryDetailResp, error)
	QueryDictionaryDetailDetail(ctx context.Context, in *QueryDictionaryDetailDetailReq, opts ...grpc.CallOption) (*QueryDictionaryDetailDetailResp, error)
	QueryAllDictionaryDetail(ctx context.Context, in *QueryAllDictionaryDetailReq, opts ...grpc.CallOption) (*QueryAllDictionaryDetailResp, error)
	UpdateDictionaryDetail(ctx context.Context, in *UpdateDictionaryDetailReq, opts ...grpc.CallOption) (*UpdateDictionaryDetailResp, error)
	DeleteDictionaryDetail(ctx context.Context, in *DeleteDictionaryDetailReq, opts ...grpc.CallOption) (*DeleteDictionaryDetailResp, error)
	QueryDictionaryList(ctx context.Context, in *QueryDictionaryListReq, opts ...grpc.CallOption) (*QueryDictionaryListResp, error)
}

type dictionaryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDictionaryServiceClient(cc grpc.ClientConnInterface) DictionaryServiceClient {
	return &dictionaryServiceClient{cc}
}

func (c *dictionaryServiceClient) CreateDictionary(ctx context.Context, in *CreateDictionaryReq, opts ...grpc.CallOption) (*CreateDictionaryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDictionaryResp)
	err := c.cc.Invoke(ctx, DictionaryService_CreateDictionary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) QueryDictionaryDetail(ctx context.Context, in *QueryDictionaryDetailReq, opts ...grpc.CallOption) (*QueryDictionaryDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryDictionaryDetailResp)
	err := c.cc.Invoke(ctx, DictionaryService_QueryDictionaryDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) QueryAllDictionary(ctx context.Context, in *QueryAllDictionaryReq, opts ...grpc.CallOption) (*QueryAllDictionaryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryAllDictionaryResp)
	err := c.cc.Invoke(ctx, DictionaryService_QueryAllDictionary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) UpdateDictionary(ctx context.Context, in *UpdateDictionaryReq, opts ...grpc.CallOption) (*UpdateDictionaryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDictionaryResp)
	err := c.cc.Invoke(ctx, DictionaryService_UpdateDictionary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) DeleteDictionary(ctx context.Context, in *DeleteDictionaryReq, opts ...grpc.CallOption) (*DeleteDictionaryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDictionaryResp)
	err := c.cc.Invoke(ctx, DictionaryService_DeleteDictionary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) CreateDictionaryDetail(ctx context.Context, in *CreateDictionaryDetailReq, opts ...grpc.CallOption) (*CreateDictionaryDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDictionaryDetailResp)
	err := c.cc.Invoke(ctx, DictionaryService_CreateDictionaryDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) QueryDictionaryDetailDetail(ctx context.Context, in *QueryDictionaryDetailDetailReq, opts ...grpc.CallOption) (*QueryDictionaryDetailDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryDictionaryDetailDetailResp)
	err := c.cc.Invoke(ctx, DictionaryService_QueryDictionaryDetailDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) QueryAllDictionaryDetail(ctx context.Context, in *QueryAllDictionaryDetailReq, opts ...grpc.CallOption) (*QueryAllDictionaryDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryAllDictionaryDetailResp)
	err := c.cc.Invoke(ctx, DictionaryService_QueryAllDictionaryDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) UpdateDictionaryDetail(ctx context.Context, in *UpdateDictionaryDetailReq, opts ...grpc.CallOption) (*UpdateDictionaryDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDictionaryDetailResp)
	err := c.cc.Invoke(ctx, DictionaryService_UpdateDictionaryDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) DeleteDictionaryDetail(ctx context.Context, in *DeleteDictionaryDetailReq, opts ...grpc.CallOption) (*DeleteDictionaryDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDictionaryDetailResp)
	err := c.cc.Invoke(ctx, DictionaryService_DeleteDictionaryDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictionaryServiceClient) QueryDictionaryList(ctx context.Context, in *QueryDictionaryListReq, opts ...grpc.CallOption) (*QueryDictionaryListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryDictionaryListResp)
	err := c.cc.Invoke(ctx, DictionaryService_QueryDictionaryList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DictionaryServiceServer is the server API for DictionaryService service.
// All implementations must embed UnimplementedDictionaryServiceServer
// for forward compatibility.
type DictionaryServiceServer interface {
	CreateDictionary(context.Context, *CreateDictionaryReq) (*CreateDictionaryResp, error)
	QueryDictionaryDetail(context.Context, *QueryDictionaryDetailReq) (*QueryDictionaryDetailResp, error)
	QueryAllDictionary(context.Context, *QueryAllDictionaryReq) (*QueryAllDictionaryResp, error)
	UpdateDictionary(context.Context, *UpdateDictionaryReq) (*UpdateDictionaryResp, error)
	DeleteDictionary(context.Context, *DeleteDictionaryReq) (*DeleteDictionaryResp, error)
	CreateDictionaryDetail(context.Context, *CreateDictionaryDetailReq) (*CreateDictionaryDetailResp, error)
	QueryDictionaryDetailDetail(context.Context, *QueryDictionaryDetailDetailReq) (*QueryDictionaryDetailDetailResp, error)
	QueryAllDictionaryDetail(context.Context, *QueryAllDictionaryDetailReq) (*QueryAllDictionaryDetailResp, error)
	UpdateDictionaryDetail(context.Context, *UpdateDictionaryDetailReq) (*UpdateDictionaryDetailResp, error)
	DeleteDictionaryDetail(context.Context, *DeleteDictionaryDetailReq) (*DeleteDictionaryDetailResp, error)
	QueryDictionaryList(context.Context, *QueryDictionaryListReq) (*QueryDictionaryListResp, error)
	mustEmbedUnimplementedDictionaryServiceServer()
}

// UnimplementedDictionaryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDictionaryServiceServer struct{}

func (UnimplementedDictionaryServiceServer) CreateDictionary(context.Context, *CreateDictionaryReq) (*CreateDictionaryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDictionary not implemented")
}
func (UnimplementedDictionaryServiceServer) QueryDictionaryDetail(context.Context, *QueryDictionaryDetailReq) (*QueryDictionaryDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDictionaryDetail not implemented")
}
func (UnimplementedDictionaryServiceServer) QueryAllDictionary(context.Context, *QueryAllDictionaryReq) (*QueryAllDictionaryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllDictionary not implemented")
}
func (UnimplementedDictionaryServiceServer) UpdateDictionary(context.Context, *UpdateDictionaryReq) (*UpdateDictionaryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDictionary not implemented")
}
func (UnimplementedDictionaryServiceServer) DeleteDictionary(context.Context, *DeleteDictionaryReq) (*DeleteDictionaryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDictionary not implemented")
}
func (UnimplementedDictionaryServiceServer) CreateDictionaryDetail(context.Context, *CreateDictionaryDetailReq) (*CreateDictionaryDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDictionaryDetail not implemented")
}
func (UnimplementedDictionaryServiceServer) QueryDictionaryDetailDetail(context.Context, *QueryDictionaryDetailDetailReq) (*QueryDictionaryDetailDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDictionaryDetailDetail not implemented")
}
func (UnimplementedDictionaryServiceServer) QueryAllDictionaryDetail(context.Context, *QueryAllDictionaryDetailReq) (*QueryAllDictionaryDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllDictionaryDetail not implemented")
}
func (UnimplementedDictionaryServiceServer) UpdateDictionaryDetail(context.Context, *UpdateDictionaryDetailReq) (*UpdateDictionaryDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDictionaryDetail not implemented")
}
func (UnimplementedDictionaryServiceServer) DeleteDictionaryDetail(context.Context, *DeleteDictionaryDetailReq) (*DeleteDictionaryDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDictionaryDetail not implemented")
}
func (UnimplementedDictionaryServiceServer) QueryDictionaryList(context.Context, *QueryDictionaryListReq) (*QueryDictionaryListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDictionaryList not implemented")
}
func (UnimplementedDictionaryServiceServer) mustEmbedUnimplementedDictionaryServiceServer() {}
func (UnimplementedDictionaryServiceServer) testEmbeddedByValue()                           {}

// UnsafeDictionaryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DictionaryServiceServer will
// result in compilation errors.
type UnsafeDictionaryServiceServer interface {
	mustEmbedUnimplementedDictionaryServiceServer()
}

func RegisterDictionaryServiceServer(s grpc.ServiceRegistrar, srv DictionaryServiceServer) {
	// If the following call pancis, it indicates UnimplementedDictionaryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DictionaryService_ServiceDesc, srv)
}

func _DictionaryService_CreateDictionary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDictionaryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).CreateDictionary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_CreateDictionary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).CreateDictionary(ctx, req.(*CreateDictionaryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_QueryDictionaryDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDictionaryDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).QueryDictionaryDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_QueryDictionaryDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).QueryDictionaryDetail(ctx, req.(*QueryDictionaryDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_QueryAllDictionary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllDictionaryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).QueryAllDictionary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_QueryAllDictionary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).QueryAllDictionary(ctx, req.(*QueryAllDictionaryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_UpdateDictionary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDictionaryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).UpdateDictionary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_UpdateDictionary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).UpdateDictionary(ctx, req.(*UpdateDictionaryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_DeleteDictionary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDictionaryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).DeleteDictionary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_DeleteDictionary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).DeleteDictionary(ctx, req.(*DeleteDictionaryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_CreateDictionaryDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDictionaryDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).CreateDictionaryDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_CreateDictionaryDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).CreateDictionaryDetail(ctx, req.(*CreateDictionaryDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_QueryDictionaryDetailDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDictionaryDetailDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).QueryDictionaryDetailDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_QueryDictionaryDetailDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).QueryDictionaryDetailDetail(ctx, req.(*QueryDictionaryDetailDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_QueryAllDictionaryDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllDictionaryDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).QueryAllDictionaryDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_QueryAllDictionaryDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).QueryAllDictionaryDetail(ctx, req.(*QueryAllDictionaryDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_UpdateDictionaryDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDictionaryDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).UpdateDictionaryDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_UpdateDictionaryDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).UpdateDictionaryDetail(ctx, req.(*UpdateDictionaryDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_DeleteDictionaryDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDictionaryDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).DeleteDictionaryDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_DeleteDictionaryDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).DeleteDictionaryDetail(ctx, req.(*DeleteDictionaryDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictionaryService_QueryDictionaryList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDictionaryListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictionaryServiceServer).QueryDictionaryList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictionaryService_QueryDictionaryList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictionaryServiceServer).QueryDictionaryList(ctx, req.(*QueryDictionaryListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DictionaryService_ServiceDesc is the grpc.ServiceDesc for DictionaryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DictionaryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.DictionaryService",
	HandlerType: (*DictionaryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDictionary",
			Handler:    _DictionaryService_CreateDictionary_Handler,
		},
		{
			MethodName: "QueryDictionaryDetail",
			Handler:    _DictionaryService_QueryDictionaryDetail_Handler,
		},
		{
			MethodName: "QueryAllDictionary",
			Handler:    _DictionaryService_QueryAllDictionary_Handler,
		},
		{
			MethodName: "UpdateDictionary",
			Handler:    _DictionaryService_UpdateDictionary_Handler,
		},
		{
			MethodName: "DeleteDictionary",
			Handler:    _DictionaryService_DeleteDictionary_Handler,
		},
		{
			MethodName: "CreateDictionaryDetail",
			Handler:    _DictionaryService_CreateDictionaryDetail_Handler,
		},
		{
			MethodName: "QueryDictionaryDetailDetail",
			Handler:    _DictionaryService_QueryDictionaryDetailDetail_Handler,
		},
		{
			MethodName: "QueryAllDictionaryDetail",
			Handler:    _DictionaryService_QueryAllDictionaryDetail_Handler,
		},
		{
			MethodName: "UpdateDictionaryDetail",
			Handler:    _DictionaryService_UpdateDictionaryDetail_Handler,
		},
		{
			MethodName: "DeleteDictionaryDetail",
			Handler:    _DictionaryService_DeleteDictionaryDetail_Handler,
		},
		{
			MethodName: "QueryDictionaryList",
			Handler:    _DictionaryService_QueryDictionaryList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}
